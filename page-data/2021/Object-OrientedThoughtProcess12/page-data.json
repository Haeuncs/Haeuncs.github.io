{"componentChunkName":"component---src-templates-blog-post-js","path":"/2021/Object-OrientedThoughtProcess12/","result":{"data":{"site":{"siteMetadata":{"title":"2021"}},"markdownRemark":{"id":"b0a00ec4-39be-5684-b037-11ea80547e8a","excerpt":"…","html":"<p>로버트 마틴에 따르면, 객체지향이란 핵심 의존성들을 역전시킴으로써 경직된 코드나 취약한 코드 및 재사용이 불가능 코드가 되지 않게 하는 식으로 의존체들을 관리하는 일이라고 말한다.</p>\n<p>경직성: 프로그램의 한 부분을 변경하면 다른 부분까지 변경해야 하는 경우</p>\n<p>취약성: 관련이 없는 곳에서 오류가 발생하는 경우</p>\n<p>부동성: 코드를 원래 맥락에서 벗어나 재사용할 수 없는 경우</p>\n<p>이러한 문제들을 해결하고 목표를 달성하기 위해 SOLID가 도입되었다.</p>\n<p>SRP: 단일 책임 원칙</p>\n<p>OCP: 개방/폐쇄 원칙</p>\n<p>LSP: 리스코프 대체 원칙</p>\n<p>ISP: 인터페이스 분리 원칙</p>\n<p>DIP: 의존성 역전 원칙</p>\n<h1 id=\"1-srp-단일-책임-원칙\" style=\"position:relative;\"><a href=\"#1-srp-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\" aria-label=\"1 srp 단일 책임 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. SRP: 단일 책임 원칙</h1>\n<p>클래스를 변경한 이유가 단일해야 한다.</p>\n<h1 id=\"2-ocp-개방폐쇄-원칙\" style=\"position:relative;\"><a href=\"#2-ocp-%EA%B0%9C%EB%B0%A9%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99\" aria-label=\"2 ocp 개방폐쇄 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. OCP: 개방/폐쇄 원칙</h1>\n<p>클래스를 수정하지 않고 클래스의 행위를 확장할 수 있어야 한다.</p>\n<h1 id=\"3-lsp-리스코프-대체-원칙\" style=\"position:relative;\"><a href=\"#3-lsp-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EB%8C%80%EC%B2%B4-%EC%9B%90%EC%B9%99\" aria-label=\"3 lsp 리스코프 대체 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. LSP: 리스코프 대체 원칙</h1>\n<p>부모 클래스의 인스턴스를 해당 자식 클래스 중 하나의 인스턴스로 교체할 수 있게 설계해야 한다. 부모 클래스가 무언가를 할 수 있다면 자식 클래스도 그것을 할 수 있어야 한다.</p>\n<h1 id=\"4-ips-인터페이스-분리-원칙\" style=\"position:relative;\"><a href=\"#4-ips-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99\" aria-label=\"4 ips 인터페이스 분리 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. IPS: 인터페이스 분리 원칙</h1>\n<p>몇 개의 큰 인터페이스가 있는 편 보다는 작은 인터페이스가 많은 편이 바람직하다.</p>\n<h1 id=\"5-dip-의존성-역전-원칙\" style=\"position:relative;\"><a href=\"#5-dip-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99\" aria-label=\"5 dip 의존성 역전 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. DIP: 의존성 역전 원칙</h1>\n<p>코드가 추상화에 의존해야 한다고 명시하고 있다.</p>\n<ul>\n<li>의존성 역전: 의존체들을 역전시키는 원칙</li>\n<li>의존성 주입: 의존체들을 역전시키는 행위</li>\n<li>생성자 주입: 생성자를  통해 의존성 주입을 수행</li>\n<li>파라미터 주입: 세터와 같은 메서드의 파라미터를 통해 의존성 주입을 수행</li>\n</ul>\n<p>의존성 역전의 목표는 구상적인 것에 결합하기보다는 추상적인 것에 결합하는 것이다.</p>\n<p>같은 맥락에서 의존성 역전 원칙의 목표 중 하나는 컴파일타임이 아니라 런타임에 객체를 선택하는 것이다.</p>","tableOfContents":"<ul>\n<li><a href=\"/2021/Object-OrientedThoughtProcess12/#1-srp-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99\">1. SRP: 단일 책임 원칙</a></li>\n<li><a href=\"/2021/Object-OrientedThoughtProcess12/#2-ocp-%EA%B0%9C%EB%B0%A9%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99\">2. OCP: 개방/폐쇄 원칙</a></li>\n<li><a href=\"/2021/Object-OrientedThoughtProcess12/#3-lsp-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EB%8C%80%EC%B2%B4-%EC%9B%90%EC%B9%99\">3. LSP: 리스코프 대체 원칙</a></li>\n<li><a href=\"/2021/Object-OrientedThoughtProcess12/#4-ips-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99\">4. IPS: 인터페이스 분리 원칙</a></li>\n<li><a href=\"/2021/Object-OrientedThoughtProcess12/#5-dip-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99\">5. DIP: 의존성 역전 원칙</a></li>\n</ul>","frontmatter":{"title":"객체지향 설계의 SOLID 원칙","date":"2021年02月28日","description":"객체지향 사고 프로세스 12장을 읽고 정리"}}},"pageContext":{"slug":"/2021/Object-OrientedThoughtProcess12/","previous":{"fields":{"slug":"/2021-cleancode-1/CleanCode4/"},"frontmatter":{"title":"[Clean Code] 4. 주석"}},"next":{"fields":{"slug":"/2021/ARCHIVE 2020 2/"},"frontmatter":{"title":"ARCHIVE 2021년 2월"}}}},"staticQueryHashes":["426816048","63159454"]}